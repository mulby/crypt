#!/usr/bin/env python

from __future__ import print_function

import argparse
import errno
import os
import random
import string
import subprocess
import sys
import tempfile

try:
    from subprocess import DEVNULL
except ImportError:
    import os
    DEVNULL = open(os.devnull, 'wb')


CRYPT_REPO_PATH = os.path.abspath(
    os.path.expanduser(
        os.getenv('CRYPT_REPO_PATH', '~/.crypt')
    )
)


def add(args):
    crypt_key_name = os.getenv('CRYPT_KEY_NAME', None)
    if crypt_key_name is None:
        raise RuntimeError('CRYPT_KEY_NAME environment variable must be set.')

    ensure_repo_exists()
    encrypted_file_path = get_encrypted_file_path(args.crypt_path)
    input_file_path = os.path.abspath(args.path)
    ensure_directory_exists(os.path.dirname(encrypted_file_path))
    gpg('--encrypt', '--output', encrypted_file_path, '--recipient', crypt_key_name, input_file_path)
    git('add', encrypted_file_path)
    git('commit', '-m', 'Added {0}'.format(args.crypt_path))


def get_encrypted_file_path(crypt_path):
    return os.path.join(CRYPT_REPO_PATH, crypt_path) + '.gpg'


def ensure_directory_exists(path_to_dir):
    try:
        os.makedirs(path_to_dir)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise


def ensure_repo_exists():
    if os.path.exists(CRYPT_REPO_PATH):
        if not os.path.isdir(CRYPT_REPO_PATH):
            raise RuntimeError('Expected {0} to be a directory.'.format(CRYPT_REPO_PATH))
    else:
        ensure_directory_exists(CRYPT_REPO_PATH)

    try:
        git('rev-parse', '--git-dir')
    except subprocess.CalledProcessError:
        git('init')

    readme_path = os.path.join(CRYPT_REPO_PATH, 'README')
    if not os.path.exists(readme_path):
        with open(readme_path, 'w') as readme:
            readme.write('This is a secure git repo containing encrypted files managed by crypt.')
        git('add', readme_path)
        git('commit', '-m', 'Create repo and README')


def git(*args, **kwargs):
    return call(['git'] + list(args), **kwargs)


def call(*args, **kwargs):
    kwargs.setdefault('cwd', CRYPT_REPO_PATH)
    kwargs.setdefault('stdout', DEVNULL)
    kwargs.setdefault('stderr', DEVNULL)
    return subprocess.check_call(*args, **kwargs)


def gpg(*args, **kwargs):
    return call(['gpg', '--no-verbose', '--quiet', '--batch'] + list(args), **kwargs)


def cat(args):
    gpg('--decrypt', get_encrypted_file_path(args.crypt_path), stdout=sys.stdout)


def ls(args):
    for root, dirs, files in os.walk(CRYPT_REPO_PATH, topdown=False):
        for name in files:
            if name.endswith('.gpg'):
                print(os.path.relpath(os.path.join(root, name[:-4]), CRYPT_REPO_PATH))


def rm(args):
    git('rm', get_encrypted_file_path(args.crypt_path))
    git('commit', '-m', 'Removed {0}'.format(args.crypt_path))


def save(args):
    if hasattr(args, 'data'):
        data = args.data
    else:
        data = sys.stdin.read()
    with tempfile.NamedTemporaryFile() as tmp_file:
        tmp_file.write(data)
        tmp_file.seek(0)

        add(argparse.Namespace(crypt_path=args.crypt_path, path=tmp_file.name))


def pwgen(args):
    chars = string.letters + string.digits + string.punctuation
    save_args = argparse.Namespace(
        crypt_path=args.crypt_path,
        data=''.join(random.choice(chars) for x in range(args.length))
    )
    save(save_args)


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title='commands')

    add_parser = subparsers.add_parser('add', help='Add a file to the secure repo')
    add_parser.add_argument('path', help='The file to add')
    add_parser.add_argument('crypt_path', help='The path within the secure repo to store the file at')
    add_parser.set_defaults(func=add)

    cat_parser = subparsers.add_parser('cat', help='Read a file in the secure repo and write its contents to stdout')
    cat_parser.add_argument('crypt_path', help='The file to read')
    cat_parser.set_defaults(func=cat)

    list_parser = subparsers.add_parser('ls', help='List files stored in the secure repo')
    list_parser.set_defaults(func=ls)

    rm_parser = subparsers.add_parser('rm', help='Remove a file from the secure repo')
    rm_parser.add_argument('crypt_path', help='The file to remove')
    rm_parser.set_defaults(func=rm)

    save_parser = subparsers.add_parser('save', help='Save data from stdin into a file in the secure repo')
    save_parser.add_argument('crypt_path', help='The path within the secure repo to store the data to')
    save_parser.set_defaults(func=save)

    pwgen_parser = subparsers.add_parser('pwgen', help='Generate a password and store it in the secure repo')
    pwgen_parser.add_argument('crypt_path', help='The path within the secure repo to store the password at')
    pwgen_parser.add_argument('--length', type=int, default=32, help='The number of characters to include in the generated password')
    pwgen_parser.set_defaults(func=pwgen)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
